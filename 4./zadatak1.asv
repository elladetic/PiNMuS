
format long e;

%kreiranje bidijagonalne matrice
n = 100;
value = 1/2;
A = diag(value *ones(1,n)) + diag(ones(1,n-1),1);

%računanje QRa
[Q, R, P] = qr(A);
%diag(R) provjera dijagonalnih elementa od R
plot(diag(R),'c*'); %samo zadnji element je jako mali!!;

%računanje svd-a
[U,S,V] = svd(A);
%semilogy(diag(S), "c*");
%diag(S) provjera singularnih vrijednosti

x = transpose(1:1:100);
b = A * x;
x_solution = R \ (Q' * b);
x_solution = P * x_solution ;


%rješavanje problema najmanjih kvadrata koristeći potpuno ortogonalnu
%dekompoziciju

r = rank(A);  %A je 100 x 100, rank je 99

R(100,100) = 0;
R11 = R(1:99, 1:99)
R12 = R(1:99, 100);
R_krnja = [R11'; R12'];

[Z, L] = qr(R_krnja); %vidjeli smo gore da je samo zadnji element jako mali

L11 = L(1:99, 1:99)';
L = transpose(L(1:99,:)); %transpose jer je donje trokutasta
S = P * Z; %ovdje Z transponirano al nisam ni gore pa nemoram transponirat sad

pr = 
tmp1 = transpose(Q(:,1:r)) * b;

opts.LT=true;
tmp2 = linsolve(L,tmp1,opts);

%opts.LT=false;
%pom = L\v;

tmp2(100,1) = 0; %to je onaj zadnji kojeg stavljam na 0 eksplicitno;
x_final_solution = S * tmp2; %na kraju množim sve sa S
%x_final_solution = S * L \

%relativne greske

rel_greska2 = norm(x-x_final_solution,2) / norm(x,2)

%usporedba s MNK punog ranga
[Q_fullrank, R_fullrank] = qr (A,0);
opts.UT = true 
x_solution_full_rank = linsolve(R_fullrank, transpose(Q_fullrank) * b);
opts.UT = false
%sad gledam matrice R, njihove uvjetovanosti


cond(R,2); %9.777787936967692e+18
cond(R); %2.535025025309796e+30
%velike razlike u uvjetovanosti

%uvjetovanosti krnjih verzija matrica
cond(R(1:99,1:99),2); %2.996715084073926
cond(R_fullrank(1:99,1:99),2); %1.267509718450060e+30
%ovdje je najveća razlika prakticki

norm(A*x_final_solution-b,2); %3.719689206972206e-13
norm(A*x_solution_full_rank-b,2); %0 
%nema velikih razlika u greškama




